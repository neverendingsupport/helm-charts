# Default values for universal-chart.

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  # @schema
  # required: true
  # @schema
  # -- (string) repository path to image without tag name.
  # Example: ghcr.io/neverendingsupport/universal-chart
  repository: null
  # @schema
  # required: true
  # @schema
  # -- (string) tag / sha of image to pull
  tag: null
  # @schema
  # enum:
  # - Always
  # - Never
  # - IfNotPresent
  # @schema
  # -- k8s image pull policy
  pullPolicy: Always

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

deployment:
  # @schema
  # type: object
  # additionalProperties: true
  # @schema
  # -- extra annotations to add to the deployment resource's metadata.
  # These annotations are key-value pairs attached directly to the Deployment
  # resource. They can be used by external tooling, operators, or for tracking
  # deployment metadata and events. For more info, see:
  # https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  annotations: {}

# @schema
# required: false
# @schema
# -- define init container(s) which will run before the "real" container
# starts. The init container runs with the same environment, volumes, and
# security context as the main container.
initContainers:
  -  # @schema
    # anyof:
    #   type: string
    #   type: null
    # @schema
    # -- (string) the image to run on init
    # if this is left as null or a false-ish value, the initContainers section of
    # the deploment will be skipped
    image: null
    # -- the command to run in the init container
    # This overrides the command in the container.  Leave it empty to just run
    # the container's default command.
    command: []
    # @schema
    # additionalProperties: true
    # type: object
    # required: false
    # not:
    #   enum:
    #     - image
    #     - command
    # @schema
    # -- a map of additional properties for the init container.  This can
    # technically be any values from the spec, though reusing image, command,
    # securityContext, volumes, env, or envFrom might cause unexpected behavior.
    extraContainerProps: {}

# Describes an AWS secretmanager secret which will define env vars
awsEnvSecrets:
  # configure the secretmanager source
  externalSecret:
    # -- secret path
    secretPath: ""
    secretStoreRef:
      # @schema
      # enum:
      # - SecretStore
      # - ClusterSecretStore
      # @schema
      # -- Is the store in this namespace or cluster-wide?
      kind: SecretStore
      # -- name of the secret store; aws-secret-manager is usually right
      name: aws-secrets-manager
  # -- name of secret to store AWS secretmanager values within
  env_secret_name: aws-env

# @schema
# type: object
# required: false
# additionalProperties:
#   anyof:
#     - type: string
#     - type: object
#       properties:
#         valueFrom:
#           type: object
#           anyof:
#             - properties:
#                 fieldRef:
#                   type: object
#                   properties:
#                     fieldPath:
#                       type: string
#                   required:
#                     - fieldPath
#               required:
#                 - fieldRef
#             - properties:
#                 secretKeyRef:
#                   type: object
#                   properties:
#                     name:
#                       type: string
#                     key:
#                       type: string
#                   required:
#                     - name
#                     - key
#               required:
#                 - secretKeyRef
#           required: true
#       required:
#         - valueFrom
# examples:
#   - |-
#     PORT: "3000"
#     DEBUG: "true"
#     POD_IP:
#       valueFrom:
#         fieldRef:
#           fieldPath: status.podIP
#     AWS_ACCESS_KEY_ID:
#       valueFrom:
#         secretKeyRef:
#           name: my-secret
#           key: aws-access-key
# @schema
# -- additional environment variables and their values.
# Supports both simple string values and complex objects with valueFrom.
extraEnvVars: {}

# @schema
# type: array
# items:
#   type: string
# @schema
# -- extra secrets to load into environment
extraEnvSecrets: []

# @schema
# type: array
# items:
#   type: string
# @schema
# -- extra configmaps to load into environment
extraEnvConfigmaps: []

# @schema
# required: false
# items:
#   type: object
#   properties:
#     name:
#       type: string
#     containerPort:
#       type: integer
#     protocol:
#       type: string  # TODO: enum
#       required: false
#       default: TCP
# @schema
# -- extra ports to be exposed directly from pods (no service)
extraContainerPorts: []

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created (things may go poorly if you set this to false)
  create: true
  # Automatically mount a ServiceAccount's API credentials
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Add additional annotations to the pod.
# Annotations are generally for "people" uses and interoperability.
# For more information check out: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# -- Add additional labels to the pods.
# Labels are generally for k8s internal use (pod selectors, etc)
# For more information check out: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# -- A "service" is basically a named port which follows a pod or pods; you
# should always use a service when networking in k8s.
# More information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # -- Define the service type
  # more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # -- Defines the port the service listens upon. This is the *external* port
  # exposed by the container, not necessarily the internal port inside the
  # container.  It also doesn't have to be 80 or 443; an ingress (if used) will
  # listen on a differnet port and communicate with the container on this
  # service/port combination.
  # more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 3000

# @schema
# type: object
# properties:
#   enabled:
#     type: boolean
#   path:
#     anyof:
#       - type: string
#       - type: "null"
#   interval:
#     anyof:
#       - type: integer
#         minimum: 1
#       - type: "null"
# @schema
# -- Configure a ServiceMonitor for scraping metrics from the service.
serviceMonitor:
  # -- Whether to create a ServiceMonitor resource.
  enabled: false
  # -- HTTP path to scrape for metrics.
  path: /metrics
  # -- Optional scrape interval (in seconds). When null, the operator default is used.
  interval: null

# -- This block is for setting up the ingress.
# More information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  # -- whether or not to use an ingress
  enabled: false
  # -- which ingress class to use (usually nginx, but could be alb)
  className: ""
  # @schema
  # additionalProperties: true
  # @schema
  # -- a map of annotations to define on the ingress resource
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

  # -- list of host blocks to listen on; host blocks define more than just a hostname
  # hosts.host -- a hostname to listen upon. If TLS is enabled, the host will
  # be selected via SNI.
  # hosts.paths -- List of path rules.  Normally you want the root for a
  # hostname to go to the root of your app, and the example commented above
  # works well for that.
  hosts: []
  # - host: chart-example.local
  #   paths:
  #     - path: /
  #       pathType: ImplementationSpecific
  # -- list of TLS certs to use.  The objects in the list have a secret name
  # where the cert will be stored and a list of hosts to include in that cert.
  # Normally this will only be a one item list, but it's technically acceptable
  # to create multiple certs. If ingress.tls.secretName isn't specified, the
  # secret will just be named "tls".
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# @schema
# properties:
#   limits:
#     title: limits
#     description: maximum values for given resource
#     required: false
#     type: object
#     properties:
#       cpu:
#         type: string
#       memory:
#         type: string
#   requests:
#     title: requests
#     description: requested values for given resource; can burst beyond
#     required: false
#     type: object
#     properties:
#       cpu:
#         type: string
#       memory:
#         type: string
# @schema
# -- resource requests and limits.
# typically you can accept the values commented below, but ideally you'd run
# this in dev with some synthetic load and then either check on the monitoring
# values from Grafana or look at the Vertical Pod Autoscaler's recomendations
# via Goldilocks.
resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# @schema
# anyof:
#   type: null
#   type: map
# @schema
# -- Configure a liveness probe, please
# more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  # httpGet:
  #   path: /
  #   port: http

# @schema
# anyof:
#   type: null
#   type: map
# @schema
# -- Configure a readiness probe, please
readinessProbe:
  # httpGet:
  #   path: /
  #   port: http

# -- set a fixed number of replicas in the deployment
# This value is ignored if autoscaling is enabled
replicaCount: 1

# @schema
# type: integer
# minimum: 0
# @schema
# -- number of old ReplicaSets to retain for rollback
revisionHistoryLimit: 3

# -- section for configuring autoscaling.
# More information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  # -- enable autoscaling
  enabled: false
  # -- miminum number of replicas to run
  minReplicas: 1
  # -- maximum number of replicas to run
  maxReplicas: 10
  # -- If CPU utilization of replicas exceeds this percentage of requested CPU, start a new replica
  targetCPUUtilizationPercentage: 80
  # -- If Memory utilization of replicas exceeds this percentage of requested Memory, start a new replica
  targetMemoryUtilizationPercentage: null

# -- Additional volumes to create
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# -- Additional volumes to mount
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- Select specific nodes to run upon
# Normally this should be an empty map
nodeSelector: {}

# -- List of taints these pods should tolerate.
# Normally this should be an empty list
tolerations: []

# -- Select roughly specific nodes to run upon.
# This is similar to node selectors, but allows a bit more fuzziness and flexibility.
# More info at https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity: {}

# -- (boolean) Add a topology spread rule across Karpenter availability zones.
spread_azs: false

# -- (boolean) Add a topology spread rule across Karpenter capacity types
# (spot vs on-demand).
spread_spot: false

# -- When deploying with multiple replicas, spread pods around using these
# rules. The default is to spread pods evenly among the Availability Zones
# defined in the cluster. With a Karpenter-managed EKS cluster (like HeroDevs
# uses), there will usually be 3 AZs in a region where a cluster is deployed.
# If a constraint omits labelSelector, the chart injects selector labels.
topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway

# @schema
# additionalProperties: true
# type: object
# required: false
# @schema
# -- A dictionary of extra attributes to add to the container spec in the
# deployment. Elements will be directly added to the deployment's
# `spec.template.spec.containers` object. Note that adding an element already
# in the deployment template like `env` or `image` will cause undesirable
# behavior.
extraContainerProps: {}
# command: ["pnpm"]
# args: ["run", "--filter", "@xeol/workflows", "start.prod"]

# -- (list) A list of extra yaml manifests to include.
# Each element will be rendered exactly as passed in
extraManifests: []

########################################
# @schema
# additionalProperties: true
# @schema
# -- Redis subchart configuration values.
# Default values are at https://artifacthub.io/packages/helm/bitnami/redis
redis:
  # -- whether or not to enable the Bitnami Redis helm chart
  enabled: false
  # -- use the bitnamilegacy registry
  image:
    repository: bitnamilegacy/redis
    # -- latest release in bitnamilegacy
    # https://hub.docker.com/r/bitnamilegacy/redis/tags
    tag: 8.2.1-debian-12-r0
  # -- beware: overriding auth in your values file might be a mistake
  auth:
    enabled: true
    usePasswordFiles: false
  tls:
    # -- enable or disable TLS
    enabled: false
  # -- autoscaling is basically always the right answer :D
  autoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPU: 80
    targetMemory: 80
  # -- use presets for resource limits.
  # See https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl
  master:
    resourcesPreset: micro
  # -- use presets for resource limits.
  # See https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl
  replica:
    resourcesPreset: micro

  # -- Prometheus Metrics enabled for redis by default
  metrics:
    # -- use the bitnamilegacy registry
    image:
      repository: bitnamilegacy/redis-exporter
      tag: 1.76.0-debian-12-r0
    enabled: true
    serviceMonitor:
      enabled: true
    prometheusRule:
      enabled: true
      # -- default rules from the Bitnami chart :shrug:
      rules:
        - alert: RedisDown
          expr: redis_up{service="{{ template "common.names.fullname" . }}-metrics"} == 0
          for: 2m
          labels:
            severity: error
          annotations:
            summary: Redis(R) instance {{ "{{ $labels.instance }}" }} down
            description: Redis(R) instance {{ "{{ $labels.instance }}" }} is down
        - alert: RedisMemoryHigh
          expr: >
            redis_memory_used_bytes{service="{{ template "common.names.fullname" . }}-metrics"} * 100
            /
            redis_memory_max_bytes{service="{{ template "common.names.fullname" . }}-metrics"}
            > 90
          for: 2m
          labels:
            severity: error
          annotations:
            summary: Redis(R) instance {{ "{{ $labels.instance }}" }} is using too much memory
            description: |
              Redis(R) instance {{ "{{ $labels.instance }}" }} is using {{ "{{ $value }}" }}% of its available memory.
        - alert: RedisKeyEviction
          expr: |
            increase(redis_evicted_keys_total{service="{{ template "common.names.fullname" . }}-metrics"}[5m]) > 0
          for: 1s
          labels:
            severity: error
          annotations:
            summary: Redis(R) instance {{ "{{ $labels.instance }}" }} has evicted keys
            description: |
              Redis(R) instance {{ "{{ $labels.instance }}" }} has evicted {{ "{{ $value }}" }} keys in the last 5 minutes.
